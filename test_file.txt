(* 1. a?.0 -> SUCCESSO --------------------------- DEADLOCK *) 
main (PPref(AIn('a'), PNil));

(* 2. a?.a!.0 -> SUCCESSO --------------------------- DEADLOCK *)
main (PPref(AIn('a'), PPref(AOut('a'), PNil)));

(* 3. 0 || 0 -> SUCESSO *)
main (PPar(PNil, PNil));

(* 4. a?.0 || a!.0 -> SUCESSO *)
main (PPar(PPref(AIn('a'), PNil) , PPref(AOut('a'), PNil)));

(* 5. a?.0 || b!.0 -> SUCCESSO --------------------------- DEADLOCK *)
main (PPar(PPref(AIn('a'), PNil), PPref(AOut('b'), PNil)));

(* 6. a?.b!.0 || a!.b?.0 -> SUCCESSO *)
main ( PPar( PPref(AIn('a'), PPref(AOut('b'), PNil)), PPref(AOut('a'), PPref(AIn('b'), PNil)) ));

(* 7. a?.b!.c?.0 || a!.b?.c!.0 -> SUCESSO *)
main ( PPar( PPref(AIn('a'), PPref(AOut('b'), PPref(AIn('c'), PNil))) , PPref(AOut('a'), PPref(AIn('b'), PPref(AOut('c'), PNil)))))

(* 8. a?.b!.c?.0 || a!.c!.b?.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar( PPref(AIn('a'), PPref(AOut('b'), PPref(AIn('c'), PNil))) , PPref(AOut('a'), PPref(AOut('c'), PPref(AIn('b'), PNil)))))

(* 9. a?.b?.0 || a!.b!.c!.0 -> SUCCESSO --------------------------- DEADLOCK *)
main ( PPar(PPref(AIn('a'), PPref(AIn('b'), PNil)), PPref(AOut('a'), PPref(AOut('b'), PPref(AOut('c'), PNil)))))

(* 10. a?.0 || a!.b!.c!.0 -> SUCCESSO --------------------------- DEADLOCK *)
main ( PPar(PPref(AIn('a'), PNil) , PPref(AOut('a'), PPref(AOut('b'), PPref(AOut('c'), PNil)))))

(* 11. 0 || a!.b!.c!.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PNil, PPref(AOut('a'), PPref(AOut('b'), PPref(AOut('c'), PNil)))) )

(* 12. a!.(0 || 0) || b!.0 *)
main ( PPar(PPref(AOut('a'), PPar(PNil, PNil)) , PPref(AOut('b'), PNil)) )

(* 12. (a!.b?.c?.0 || a?.b!.0) || c!.0 -> SUCESSO *)
main ( PPar( PPar( PPref(AOut('a'), PPref(AIn('b'), PPref(AIn('c'), PNil))) , PPref(AIn('a'), PPref(AOut('b'), PNil))) , PPref(AOut('c'), PNil)) )

(* Caso especial em que temos de verificar o LChi -> falta fazer *)
(* 13. a!.b?.0 || a?.0 || a?.a!.b!.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar( PPar( PPref(AOut('a'), PPref(AIn('b'), PNil)) , PPref(AIn('a'), PNil)) , PPref(AIn('a'), PPref(AOut('a'), PPref(AOut('b'), PNil))) ) )

(* 14. a!.0 || a?.0 || a?.a!.b!.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar( PPar(PPref(AOut('a'), PNil) , PPref(AIn('a'), PNil)) , PPref( AIn('a') , PPref(AOut('a') , PPref(AOut('b') , PNil)))) )

(* 15. b!.a!.0 || a?.0 || b?.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar( PPar( PPref(AOut('b'), PPref(AOut('a'), PNil) ) , PPref(AIn('a'), PNil)), PPref(AIn('b'), PNil)) )

(* 16. 0 || a?.0 || a!.0 -> SUCESSO *)
main ( PPar(PPar(PNil, PPref(AIn('a'), PNil) ), PPref(AOut('a'), PNil)) )

(* 17. a?.0 || 0 || b!.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PPar(PPref(AIn('a'), PNil), PNil) , PPref(AOut('b'), PNil)) )

(* 18. a?.0 || 0 || a?.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PPar( PPref(AIn('a'), PNil), PNil) , PPref(AIn('a'), PNil)) )

(* 19. a?.a?.0 || 0 || a?.b!.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PPar(PPref(AIn('a'), PPref(AIn('a'), PNil)) , PNil) , PPref(AIn('a') , PPref(AOut('b'), PNil))) )

(* 20. a?.a?.0 || b?.c?.0 || a?.b!.0 -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PPar(PPref(AIn('a') , PPref(AIn('a'), PNil)) , PPref(AIn('b'), PPref(AIn('c'), PNil))) , PPref(AIn('a'), PPref(AOut('b'), PNil))) )

(* 21. a?.(b!.0 || c?.d?.0) || b?.0 || a!.(c!.0 || d!.0) -> SUCESSO *)
main ( PPar( PPar(PPref(AIn('a'), PPar(PPref(AOut('b'), PNil) , PPref(AIn('c'), PPref(AIn('d'), PNil)))) , PPref(AIn('b'), PNil) ) , PPref(AOut('a'), PPar(PPref(AOut('c'), PNil), PPref(AOut('d'), PNil)))) )

(* 22. 0 || 0 || 0  -> SUCESSO *)
main ( PPar(PPar(PNil, PNil) , PNil) )

(* Caso especial: ver permutação 3 -> O que fazer caso num LChi existam 2 ou mais ações correspondentes à da Lista (ou mesmo dentro do Chi)? *)
(* 23. b!.(0 || 0) || b?.0 || b?.b!.(a!.0 || a?.0) -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PPar(PPref(AOut('b'), PPar(PNil, PNil)), PPref(AIn('b'), PNil) ), PPref(AIn('b'), PPref(AOut('b'), PPar(PPref(AOut('b'), PNil) , PPref(AIn('b'), PNil))))) )

(* 24. a!.0 || b!.0 || a?.0 || b?.0 -> SUCESSO *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PNil), PPref(AOut('b'), PNil)) , PPref(AIn('a'), PNil)) , PPref(AIn('b'), PNil)) )

(* 25. a!.(b!.(c!.0 || d?.0) || b?.0) || a?.c?.d!.0 -> SUCESSO *)
main ( PPar( PPref(AOut('a'), PPar(PPref(AOut('b'), PPar(PPref(AOut('c'), PNil), PPref(AIn('d'), PNil))) , PPref(AIn('b'), PNil))) , PPref(AIn('a'), PPref(AIn('c'), PPref(AOut('d'), PNil)))) )

(* 26. a!.(b!.(c!.0 || d?.0) || b?.0) || a?.(c?.0 || e!.0) -> SUCESSO --------------------------- DEADLOCK *)
main ( PPar(PPref(AOut('a'), PPar(PPref(AOut('b'), PPar(PPref(AOut('c'), PNil), PPref(AIn('d'), PNil))), PPref(AIn('b'), PNil))) , PPref(AIn('a'), PPar(PPref(AIn('c'), PNil), PPref(AOut('e'), PNil)))) )

(* 27. a!.(a!.(a?.0 || a?.0 ) || a!) || a?.(a?.0 || a?.0 || a!.0) -> STACK OVERFLOW *)
main ( PPar(PPref(AOut('a'), PPar( PPref(AOut('a'), PPar(PPref(AIn('a'), PNil), PPref(AIn('a'), PNil))) , PPref(AOut('a'), PNil))) , PPref(AIn('a'), PPar(PPar(PPref(AIn('a'), PNil), PPref(AIn('a'), PNil)), PPref(AOut('a'), PNil) )) ) )

(* 28. a!.(a!.(b?.0 || c?.0 )) || a?.(a?.0 || b!.0 || c!.0) -> SUCESSO *)
main ( PPar(PPref(AOut('a'), PPref(AOut('a'), PPar(PPref(AIn('b'), PNil), PPref(AIn('c'), PNil)))) , PPref(AIn('a'), PPar(PPar(PPref(AIn('a'), PNil), PPref(AOut('b'), PNil)), PPref(AOut('c'), PNil) )) ) )

(* 29. a!.(a!.(b?.0 || c?.0 ) || d!.0) || a?.(a?.0 || b!.0 || c!.0 || d?.0) -> STACK OVERFLOW *)
main ( PPar(PPref(AOut('a'), PPar( PPref(AOut('a'), PPar(PPref(AIn('b'), PNil), PPref(AIn('c'), PNil))) , PPref(AOut('d'), PNil))) , PPref(AIn('a'), PPar(PPar(PPar(PPref(AIn('a'), PNil), PPref(AOut('b'), PNil)), PPref(AOut('c'), PNil) ), PPref(AIn('d'), PNil))) ) )

(* 30. a!.b?.0 || c?.d?.a!.0 || c!.a?.0 || b!.d!.a?.0 *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PPref(AIn('b'), PNil)), PPref(AIn('c'), PPref(AIn('d'), PPref(AOut('a'), PNil)))), PPref(AOut('c'), PPref(AIn('a'), PNil))) , PPref(AOut('b'), PPref(AOut('d'), PPref(AIn('a'), PNil)))) )

(* 31. a!.a?.0 || a?.a?.a!.0 || a!.a?.0 || a!.a!.a?.0 || a!.a?.0*)
main ( PPar(PPar(PPar(PPar(PPref(AOut('a'), PPref(AIn('a'), PNil)), PPref(AIn('a'), PPref(AIn('a'), PPref(AOut('a'), PNil)))), PPref(AOut('a'), PPref(AIn('a'), PNil))) , PPref(AOut('a'), PPref(AOut('a'), PPref(AIn('a'), PNil)))), PPref(AOut('a'), PPref(AIn('a'), PNil))) )

(* 32. (a!.0 || a?.0) + (b!.0 || b?.0) *)
main ( POr(PPar(PPref(AOut('a'), PNil), PPref(AIn('a'), PNil)), PPar(PPref(AOut('b'), PNil), PPref(AIn('b'), PNil))) )

(* 33. a!.(b?.0 + 0) || a?.b!.0 *)
main ( PPar(PPref(AOut('a'), POr(PPref(AIn('b'), PNil), PNil)), PPref(AIn('a'), PPref(AOut('b'), PNil))) )

(* 34. a!.0 + b!.0 + c!.0 *)
main ( POr(POr(PPref(AOut('a'), PNil), PPref(AOut('b'), PNil)), PPref(AOut('c'), PNil) ) )

(* 35. (a!.0 || a?.0) + (b!.0 || b?.0) + (c!.0 || c?.0) *)
main ( POr(POr(PPar(PPref(AOut('a'), PNil), PPref(AIn('a'), PNil)), PPar(PPref(AOut('b'), PNil), PPref(AIn('b'), PNil))), PPar(PPref(AOut('c'), PNil), PPref(AIn('c'), PNil))  ))

(* 36. (a!.0 || a?.0) + (a!.0 || a?.b?.(c?.0 + d?.0) || b!.d!.0 ) *)
main ( POr(PPar(PPref(AOut('a'), PNil), PPref(AIn('a'), PNil)), PPar(PPar(PPref(AOut('a'), PNil), PPref(AIn('a'), PPref(AIn('b'), POr(PPref(AIn('c'), PNil), PPref(AIn('d'), PNil))))), PPref(AOut('b'), PPref(AOut('d'), PNil))) ) )



(* Listing 3 *)
(* a!.0 || a?.b!.0 || a?.b!0 || b?.b?.0 -> DEADLOCK --- SUCCESSO *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PNil), PPref(AIn('a'), PPref(AOut('b'), PNil))), PPref(AIn('a'), PPref(AOut('b'), PNil))), PPref(AIn('b'), PPref(AIn('b'), PNil))) )

(* Listing 7 -> Prime sieve *)
(* a!.a!.0 || a?.b?.0 || a?.0 + b!.0  -> DEADLOCK -- Depende do nº de gerações *)
main ( PPar(PPar(PPref(AOut('a'), PPref(AOut('a'), PNil)), PPref(AIn('a'), PPref(AIn('b'), PNil))), POr(PPref(AIn('a'), PNil), PPref(AOut('b'), PNil))) )

(* Listing 8 -> Fan-in pattern *)
(* a!.0 || b!.0 || a?.c!.0 + b?.c!.0 || c?.0 -> DEADLOCK -- porque há 2 Works e apenas uma receção *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PNil), PPref(AOut('b'), PNil)), POr(PPref(AIn('a'), PPref(AOut('c'), PNil)), PPref(AIn('b'), PPref(AOut('c'), PNil)))), PPref(AIn('c'), PNil)) )

(* a!.0 || b!.0 || a?.c!.(a?.c!.0 + b?.c!.0) + b?.c!.(a?.c!.0 + b?.c!.0) || c?.c?.0 -> DEADLOCK POSSÍVEL -- por causa da escolha *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PNil), PPref(AOut('b'), PNil)), POr(PPref(AIn('a'), PPref(AOut('c'), POr(PPref(AIn('a'), PPref(AOut('c'), PNil)), PPref(AIn('b'), PPref(AOut('c'), PNil)) ))), PPref(AIn('b'), PPref(AOut('c'), POr(PPref(AIn('a'), PPref(AOut('c'), PNil)), PPref(AIn('b'), PPref(AOut('c'), PNil)) ))))), PPref(AIn('c'), PPref(AIn('c'), PNil))) )

(* a!.0 || b!.0 || a?.c!.b?.c!.0 + b?.c!.a?.c!.0 || c?.c?.0  *)


(* Listing 9 -> Alternative fan-in pattern *)
(* a!.0 || b!.0 || (a?.c!.0 + b!.c!.0 + 0) || (c?.0 + 0) -> DEADLOCK -- porque há 2 works e apenas uma receção *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PNil), PPref(AOut('b'), PNil)), POr(POr(PPref(AIn('a'), PPref(AOut('c'), PNil)), PPref(AIn('b'), PPref(AOut('c'), PNil))), PNil)), POr(PPref(AIn('c'), PNil), PNil)) )

(* a!.0 || b!.0 || a?.c!.(a?.c!.0 + b?.c!.0 + 0) + b?.c!.(a?.c!.0 + b?.c!.0 + 0) + 0 || c?.c?.0 -> DEADLOCK POSSÍVEL -- por causa da escolha *)
main ( PPar(PPar(PPar(PPref(AOut('a'), PNil), PPref(AOut('b'), PNil)), POr(POr(PPref(AIn('a'), PPref(AOut('c'), POr(POr(PPref(AIn('a'), PPref(AOut('c'), PNil)), PPref(AIn('b'), PPref(AOut('c'), PNil))), PNil))), PPref(AIn('b'), PPref(AOut('c'), POr(POr(PPref(AIn('a'), PPref(AOut('c'), PNil)), PPref(AIn('b'), PPref(AOut('c'), PNil))), PNil))) ), PNil) ), PPref(AIn('c'), PPref(AIn('c'), PNil))) )

(* ----------- cond-recur ----------- -> o programa MiGo parece estar mal feito *) (* t0 = a, t1=b *)
(* b!.b!.0 + b!.0 || a?.0 + b?.b?.0 *) (* -> maneira errada *)
main ( PPar(POr(PPref(AOut('b'), PPref(AOut('b'), PNil)), PPref(AOut('b'), PNil)), POr(PPref(AIn('a'), PNil), PPref(AIn('b'), PPref(AIn('b'), PNil)))) )

(* (b!.(b!.0 + a!.0) + a!.(b!.0 + a!.0)) || (a?.0 + b?.b?.0) -> maneira que eu acho correta *)
main ( PPar( POr(PPref(AOut('b'), POr(PPref(AOut('b'), PNil), PPref(AOut('a'), PNil))), PPref(AOut('a'), POr(PPref(AOut('b'), PNil), PPref(AOut('a'), PNil)))), POr(PPref(AIn('a'), PNil), PPref(AIn('b'), PPref(AIn('b'), PNil)))) )

(* ----------- Forselect ----------- *)
(* b?.a!.0 + c!.0 || c?.0 + b!.a!.0 || a?.a?.0 -> DEADLOCK POSSÍVEL -- por causa da escolha *)
main ( PPar(PPar(POr(PPref(AIn('b'), PPref(AOut('a'), PNil)), PPref(AOut('c'), PNil)), POr(PPref(AIn('c'), PNil), PPref(AOut('b'), PPref(AOut('a'), PNil)))), PPref(AIn('a'), PPref(AIn('a'), PNil))) )

(* b?.a!.0 + c!.(b?.a!.0 + c!.0) || c?.(c? + b!.a!.0) + b!.a!.0 || a?.a?.0 -> DEADLOCK POSSÍVEL -- por causa da escolha *)
main ( PPar(PPar(POr(PPref(AIn('b'), PPref(AOut('a'), PNil)), PPref(AOut('c'), POr(PPref(AIn('b'), PPref(AOut('a'), PNil)), PPref(AOut('c'), PNil)))) , POr(PPref(AIn('c'), POr(PPref(AIn('c'), PNil), PPref(AOut('b'), PPref(AOut('a'), PNil)))), PPref(AOut('b'), PPref(AOut('a'), PNil))) ), PPref(AIn('a'), PPref(AIn('a'), PNil))) )

(* ----------- Giachino dining philosopher ----------- *)
(* Stack overflow em 1.7.1.1.1.1.1.1.1.60.2.2.12.3.1.2.1 *)
(* a!.a?.0 || b!.b?.0 || c!.c?.0 || a?.(b?.a!.b!.0 + a!.0) + b?.(a?.b!.a!.0 + b!.0) || b?.(c?.b!.c!.0 + b!.0) + c?.(b?.c!.b!.0 + c!.0) || 
c?.(a?.c!.a!.0 + c!.0) + a?.(c?.a!.c!.0 + a!.0) *)
main ( PPar(PPar(PPar(PPar(PPar(PPref(AOut('a'), PPref(AIn('a'), PNil)), PPref(AOut('b'), PPref(AIn('b'), PNil))), PPref(AOut('c'), PPref(AIn('c'), PNil))), 
POr( PPref(AIn('a'), POr(PPref(AIn('b'), PPref(AOut('a'), PPref(AOut('b'), PNil))), PPref(AOut('a'), PNil))), 
PPref(AIn('b'), POr(PPref(AIn('a'), PPref(AOut('b'), PPref(AOut('a'), PNil))), PPref(AOut('b'), PNil))))),
POr( PPref(AIn('b'), POr(PPref(AIn('c'), PPref(AOut('b'), PPref(AOut('c'), PNil))), PPref(AOut('b'), PNil))),
PPref(AIn('c'), POr(PPref(AIn('b'), PPref(AOut('c'), PPref(AOut('b'), PNil))), PPref(AOut('c'), PNil))))), 
POr(PPref(AIn('c'), POr(PPref(AIn('a'), PPref(AOut('c'), PPref(AOut('a'), PNil))), PPref(AOut('c'), PNil))),
PPref(AIn('a'), POr(PPref(AIn('c'), PPref(AOut('a'), PPref(AOut('c'), PNil))), PPref(AOut('a'), PNil))))) )

(* ----------- Jobsched ----------- *)
(* Um canal fechado consegue sempre receber valores, e neste caso o canal done, quando fechado, é usado para terminar o programa, 
pelo que se tem de considerar que close(done) envia uma mensagem, caso contrário dá sempre deadlock *)
(* No entanto há uma discrepância entre o nº de closes e leituras do respetivo canal, uma vez que basta fechar 1 vez e pode ser lido infinitamente *)
(* a?.0 + b?.0 || a?.0 + b?.0 || a!.(a!.0 + b!.0) + b!.0 *)
main ( PPar(PPar(POr(PPref(AIn('a'), PNil), PPref(AIn('b'), PNil)), POr(PPref(AIn('a'), PNil), PPref(AIn('b'), PNil))),  POr(PPref(AOut('a'), POr( PPref(AOut('a'), PNil), PPref(AOut('b'), PNil))), PPref(AOut('b'), PNil))) )

(* ----------- select-with-continuation ----------- -> DEADLOCK sempre *)
(* a?.a!.0 + b!.a!.0 + c?.a!.0 + a!.0 *)
main ( POr(POr(POr(PPref(AIn('a'), PPref(AOut('a'), PNil)), PPref(AOut('b'), PPref(AOut('a'), PNil))), PPref(AIn('c'), PPref(AOut('a'), PNil))), PPref(AOut('a'), PNil)) )


------------------ godel2-benchmarks ------------------

(* ch-as-lock-bad *)
(* b?.b!.b?.b!.0 || b?.b!.0                       TEM SOLUÇÃO -> Nota: Canal assíncrono                    *)
main ( PPar(PPref(AIn('b'), PPref(AOut('b'), PPref(AIn('b'), PPref(AOut('b'), PNil)))), PPref(AIn('b'), PPref(AOut('b'), PNil)) ) ) 

(* ch-as-lock-fix / ch-as-lock-race *)
(* b!.b?.b!.b?.0 || b!.b?.0                       TEM SOLUÇÃO -> Nota: Canal assíncrono                    *)
main ( PPar(PPref(AOut('b'), PPref(AIn('b'), PPref(AOut('b'), PPref(AIn('b'), PNil)))), PPref(AOut('b'), PPref(AIn('b'), PNil))) )

(* deposit-fix -> Não tem comunicação *)
(* deposit-race -> Não tem comunicação *)
(* dine3-chan-fix -> Tem processos recursivos *)
(* dine3-chan-race -> Tem processos recursivos *)
(* dine5-chan-fix -> Tem processos recursivos *)
(* dine5-chan-race -> Tem processos recursivos *)
(* dine5-chan-deadlock-> Não tem comunicação *)
(* dine5-fix -> Não tem comunicação *)
(* dine5-unsafe -> Não tem comunicação *)
(* loop -> Tem processos recursivos e loops *)
(* no-race -> Não tem comunicação *)
(* no-race-mut-bad -> Não tem comunicação *)
(* no-race-mutex -> Não tem comunicação *)
(* prod-cons-fix -> Tem processos recursivos *)
(* prod-cons-race -> Tem processos recursivos *)
(* simple-race -> Não tem comunicação *)
(* simple-race-fix -> Não tem comunicação *)